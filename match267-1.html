<html>
<head>
<title>A67_Sec17_24101487_Priyota-Banik.txt</title>
</head>
<body bgcolor="white">
<hr/>
A67_Sec05_24101524_MD.-Abdullah-Al-Jarif.txt<p></p><pre>
MD. Abdullah Al Jarif
ID: 24101524

public class Task4 {

    //===================================TASK#4===================================
    // This method takes only 3 parameters
    // 1st one is root of the given tree
    // 2nd one is there to help you count the levels
    // 3rd one is the level TILL whic you need to swap childs
    // All the changes will happen in-place
    // This method doesn't return anything
    // You can use extra helper private static methods as per need
<a name="0"></a><font color="#FF0000"><a href="match267-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_18.gif"/></a>

    public static void swapChild( BTNode root, int lvl, int M ){
        if (root == null){
            return;
        }
        if (lvl&lt;M){
            BTNode temp = root.left;
            root.left = root.right;
            root.right = temp;
        }
        swapChild (root.left, lvl+1, M);
        swapChild (root.right, lvl+1, M);
    }
}


public class Task5 {

    //===================================TASK#5===================================
    // This method takes only 1 parameter which is root of the given tree
    // This method returns an Integer
    // At times you may need to typeCast root.elem to Integer
    // You can use extra helper private static methods with extra extra params as per need
    public static Integer subtractSummation( BTNode root ){
        if (root == null){
            return 0;
        }
        return sumLeft(root.left)-sumRight(root.right);
</font>    }
    //============================================================================
    private static int sumLeft(BTNode root){
        if (root == null){
            return 0;
        }
        return (Integer)root.elem + sumLeft(root.left) + sumLeft(root.right);
    }
    private static int sumRight(BTNode root){
        if (root == null){
            return 0;
        }
<a name="4"></a><font color="#FF00FF"><a href="match267-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

        return (Integer)root.elem + sumRight(root.left) + sumRight(root.right);
    }

}


public class Task6 {

    //===================================TASK#6===================================
    // This method takes only 1 parameter which is root of the given tree
    // This method returns an Integer
    // At times you may need to typeCast root.elem to Integer
    // You can use extra helper private static methods with extra extra params as per need
    public static Integer levelSum( BTNode root ){
        return levelhelper(root, 0);
</font>    }
    //============================================================================
    public static int levelhelper(BTNode root, int level) {
        if (root == null) {
            return 0;
        }
        int sum = 0;
        if(level % 2 == 0){
            sum -= (int) root.elem;
        }
        else{
            sum += (int) root.elem;
        }
<a name="2"></a><font color="#0000FF"><a href="match267-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

        return sum + levelhelper(root.left, level + 1) + levelhelper(root.right, level + 1);
    }

}





 public class Task4 {

    //===================================TASK#4======================
    // This method takes only three parameters
    // first one is the root of the given tree
    // second one the low range and third one is high range
    // You can use extra helper private static methods as per need
    public static Integer rangeSum( BSTNode root, Integer low, Integer high ){
        if (root == null){
            return 0;
        }

        Integer sum = 0;
</font>        if (root.elem &lt;= high &amp;&amp; root.elem &gt;= low){
            sum += root.elem;
        }

        if (root.elem &gt; low){
            sum += rangeSum(root.left, low, high);
        }

        if (root.elem &lt; high){
            sum += rangeSum(root.right, low, high);
        }

        return sum; // remove this line
    }
    //===============================================================


}


<a name="1"></a><font color="#00FF00"><a href="match267-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

public class Task5 {

    //===================================TASK#5======================
    // This method takes only one parameter
    // it is root of the given tree
    // You can use extra helper private static methods as per need
    public static Integer mirrorSum( BSTNode root ){
        if (root == null){
            return 0;
        }
        return helper(root.left, root.right);
    }
    //===============================================================
    private static Integer helper(BSTNode left, BSTNode right){

        if (left == null || right == null){
            return 0;
        }

        Integer sum = left.elem + right.elem;
</font><a name="3"></a><font color="#00FFFF"><a href="match267-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

        
        sum += helper(left.left, right.right);
        sum += helper(left.right, right.left);


        return sum;

    }


}



public class Task6 {

    //===================================TASK#6======================
    // This method takes only one parameter
    // it is root of the given tree
    // You can use extra helper private static methods as per need
    public static Boolean isBST( BSTNode root ){
</font>        return minmax(root, null, null);
    }
    //===============================================================
    private static Boolean minmax(BSTNode root, Integer min, Integer max){
        if (root == null){
            return true;
        }

        if (min != null &amp;&amp; root.elem &lt;= min || max != null &amp;&amp; root.elem &gt;= max){
            return false;
        }

        return minmax(root.left, min, root.elem) &amp;&amp; minmax(root.right, root.elem, max);
    }


}



</pre>
</body>
</html>
