<html>
<head>
<title>A67_Sec10_24101246_Nahiyan-Mysha-Ayome.txt</title>
</head>
<body bgcolor="white">
<hr/>
A67_Sec21_24101440_RAAIDA-SABAHAT-NASIR.txt<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match208-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

ï»¿//Assignment 6
public class Task4 {


    //===================================TASK#4===================================
    // This method takes only 3 parameters
    // 1st one is root of the given tree
    // 2nd one is there to help you count the levels
    // 3rd one is the level TILL whic you need to swap childs
    // All the changes will happen in-place
    // This method doesn't return anything
    // You can use extra helper private static methods as per need
    public static void swapChild( BTNode root, int lvl, int M ){
        //TO DO
        if(root==null){
            return;
        }
        if(lvl&lt;M){
            BTNode temp=root.left;
            root.left=root.right;
            root.right=temp;
        }
        swapChild(root.left, lvl+1, M);
        swapChild(root.right, lvl+1, M);
    }
    //============================================================================
}


public class Task5 {


    //===================================TASK#5===================================
    // This method takes only 1 parameter which is root of the given tree
    // This method returns an Integer
    // At times you may need to typeCast root.elem to Integer
    // You can use extra helper private static methods with extra extra params as per need
    public static Integer subtractSummation( BTNode root ){
</font>        //TO DO
<a name="1"></a><font color="#00FF00"><a href="match208-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

        int sumLeft=sum(root.left);
        int sumRight=sum(root.right);
        return sumLeft-sumRight;
    }
    public static Integer sum(BTNode root){
        if(root==null){
            return 0;
        }
        return (Integer)root.elem+sum(root.right)+sum(root.left);
    //============================================================================
    }
}




public class Task6 {


    //===================================TASK#6===================================
    // This method takes only 1 parameter which is root of the given tree
    // This method returns an Integer
    // At times you may need to typeCast root.elem to Integer
    // You can use extra helper private static methods with extra extra params as per need
    public static Integer levelSum( BTNode root ){
</font>        //TO DO
        return SumLevel(root,0);
    }
    public static Integer SumLevel(BTNode root, int lvl){
        if(root==null){
            return 0;
        }
        if(lvl%2==0){
            return -(Integer)root.elem+SumLevel(root.left, lvl+1)+SumLevel(root.right, lvl+1);
        }
        else{
            return (Integer)root.elem+SumLevel(root.left, lvl+1)+SumLevel(root.right, lvl+1);
        }
       
    }
    //============================================================================


}


//Assignment 7
<a name="2"></a><font color="#0000FF"><a href="match208-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

public class Task4 {


    //===================================TASK#4======================
    // This method takes only three parameters
    // first one is the root of the given tree
    // second one the low range and third one is high range
    // You can use extra helper private static methods as per need
    public static Integer rangeSum( BSTNode root, Integer low, Integer high ){
        //TO DO
        if(root==null){
            return 0;
        }
        int value=0;
        if(root.elem&gt;=low &amp;&amp; root.elem&lt;=high){
            value+=root.elem;
</font>        }
        return value+rangeSum(root.left, low, high)+rangeSum(root.right, low, high);
       
    //===============================================================
    }
}


public class Task5 {


    //===================================TASK#5======================
    // This method takes only one parameter
    // it is root of the given tree
    // You can use extra helper private static methods as per need
    public static Integer mirrorSum( BSTNode root ){
        //TO DO
<a name="4"></a><font color="#FF00FF"><a href="match208-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

        return SumMirror(root.left, root.right);
    }
    public static Integer SumMirror(BSTNode left, BSTNode right){
        if(left==null || right==null){
            return 0;
</font>        }
        int sum=0;
        if(left!=null &amp;&amp; right!=null){
<a name="3"></a><font color="#00FFFF"><a href="match208-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

            sum+=left.elem+right.elem;
        }
        sum+=SumMirror(left.left, right.right);
        sum+=SumMirror(left.right, right.left);
        return sum;
    }
       
    //===============================================================




}




public class Task6 {


    //===================================TASK#6======================
    // This method takes only one parameter
    // it is root of the given tree
    // You can use extra helper private static methods as per need
    public static Boolean isBST( BSTNode root ){
</font>        //TO DO
        int size=countNode(root);
        int[] arr=new int[size];
        inOrder(root, arr, 0);
        for(int i=0;i&lt;size-1;i++){
            if(arr[i]&gt;=arr[i+1]){
                return false;
            }
        }
        return true;
    }
    public static int countNode(BSTNode root){
        if(root==null){
            return 0;
        }
        return 1+countNode(root.left)+countNode(root.right);
    }
    public static void inOrder(BSTNode root, int[] arr, int index){
        if(root==null){
            return;
        }
        inOrder(root.left, arr, index);
        arr[index]=root.elem;
        index++;
        inOrder(root.right, arr, index);
    }</pre>
</body>
</html>
