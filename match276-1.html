<html>
<head>
<title>A67_Sec01_23301144_MD.RIFAT-ABDULLAH-SARKER.txt</title>
</head>
<body bgcolor="white">
<hr/>
A67_Sec12_22241113_Aishwarja-Ghosh.txt<p></p><pre>
//Assignment 6
//task4
public class Task4 {
    public static void swapChild(BTNode root, int lvl, int M) {
        if (root == null)  // base case- if the current node is null, swap korbo na
          return;
        if (lvl &lt; M) { // if the current level is less than M, swap korbo
            BTNode temp = root.left;
            root.left = root.right;  // swap the left and right children
<a name="0"></a><font color="#FF0000"><a href="match276-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_22.gif"/></a>

            root.right = temp;
 // recursively swap in the left and right subtrees and increasing the level count
            swapChild(root.left,  lvl + 1, M);
            swapChild(root.right, lvl + 1, M);
        }
        // If lvl &gt;= M, stop recursion — ar swap hobe na
    }
}

//task5
public class Task5 {
    public static Integer subtractSummation(BTNode root) {
        if (root == null) 
          return 0; // if the tree is empty, return 0 korbo as there is no left,right subtree
        // sum of left subtree
        int leftSum  = sum(root.left);

        // sum of right subtree
        int rightSum = sum(root.right);

        // return left sum minus right sum
        return leftSum - rightSum;
    }

    // Helper method for add up all node values in a subtree
    private static int sum(BTNode node) {
        if (node == null) 
          return 0;
        int val = (Integer) node.elem; // casting the object to Integer before adding
        return val + sum(node.left) + sum(node.right);  // sum = current node's value + sum of left subtree + sum of right subtree
    }
}

//task6

public class Task6 {
    public static Integer levelSum(BTNode root) {
        return fncHelper(root, 0); // level 0 (root) theke recursion shuru
</font>    }

    // Recursively calculating sum(odd levels) − sum(even levels)
    private static int fncHelper(BTNode node, int level) {
        if (node == null) 
          return 0;
        int val = (Integer) node.elem;  // node's integer value pauar jonno

        // If level is even- subtract from total and if odd - add to total
       int sign;
       if (level % 2 == 0) {
           sign = -1;
           } 
       else {
         sign = 1;
         }
      int leftSum = fncHelper(node.left, level + 1);   // go to left child
      int rightSum = fncHelper(node.right, level + 1); // go to right child
<a name="2"></a><font color="#0000FF"><a href="match276-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

      int currentValue = sign * val;                    // add or subtract current node value
      return currentValue + leftSum + rightSum;         // total sum for this part of tree
    }
}


//assignment07

//task04
public class Task4 {
    public static Integer rangeSum(BSTNode root, Integer low, Integer high) {
        if (root == null)  // if the tree is empty, return 0 as there is no left and right subtree
          return 0;
</font>
        // if current node is less than low,  left subtree baad jabe
        if (root.elem &lt; low) 
          return rangeSum(root.right, low, high);

        // if current node is greater than high, right subtree baad jabe
        if (root.elem &gt; high) 
          return rangeSum(root.left, low, high);

        // if current node is within range, value add and check both sides
        return root.elem + rangeSum(root.left, low, high) + rangeSum(root.right, low, high);
    }
}

//task05

public class Task5 {
    public static Integer mirrorSum(BSTNode root) {
        return mirrorHelper(root.left, root.right); //start from left and right children of root
    }

    // helper method to compare mirror nodes
<a name="1"></a><font color="#00FF00"><a href="match276-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

    private static Integer mirrorHelper(BSTNode left, BSTNode right) {
        if (left == null || right == null) 
          return 0; // if any node is missing, no mirror exists

        // add values of mirror nodes and check their children
        int sum = left.elem + right.elem;

        // check outer and inner mirrors
        sum += mirrorHelper(left.left, right.right);
        sum += mirrorHelper(left.right, right.left);

        return sum;
    }
}

//task06

public class Task6 {
    public static Boolean isBST(BSTNode root) {
        return isBSThlpr(root, Integer.MIN_VALUE, Integer.MAX_VALUE);  // start with full range of valid values
    }

    // helper method to check bst validity
    private static Boolean isBSThlpr(BSTNode node, int min, int max) {
        // empty tree is valid
        if (node == null) 
          return true;
 // If current node dont follow bst rule, return false
        if (node.elem &lt; min || node.elem &gt; max) 
          return false;
</font>
// check if the left child is a valid bst within the range [min, node.elem - 1]
// check if the right child is a valid bst within the range [node.elem + 1, max]
boolean leftValid = isBSThlpr(node.left, min, node.elem - 1);
boolean rightValid = isBSThlpr(node.right, node.elem + 1, max);
return leftValid &amp;&amp; rightValid;
    }
}






</pre>
</body>
</html>
